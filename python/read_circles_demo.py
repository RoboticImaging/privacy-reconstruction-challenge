import scipy.interpolate
import scipy.io
import numpy as np


def generate_hash(img, circ_info, n_interp_samples):
    """
    Given an image and the information about where the circles were drawn in
    the original MATLAB implementation, generate the hash values for the
    image.

    Parameters
    ----------
    img : np.ndarray
        The image to generate the hash for.
    circ_info : np.ndarray
        The information about the circles in the image. This is a 3-column
        array where each row is a circle. The columns are radius, x, and y. This
        function takes inputs of the form circle_info_all_imgs[0] where
        circle_info_all_imgs is the array of circle information directly read
        from the mat file.
    n_interp_samples : int
        The number of samples to take around the circle. This was set as 500
        when the data was generated.

    Returns
    -------
    hash_vals : np.ndarray
        A 2-column array where each row is the maximum and minimum pixel
        values around the circle. This is the hash value for the circle.

    """
    hash_vals = np.zeros((len(circ_info), 2))
    theta_samples = np.linspace(0, 2 * np.pi, n_interp_samples, endpoint=False)
    interp_function = scipy.interpolate.RegularGridInterpolator(
        (range(img.shape[0]), range(img.shape[1])),
        img,
        method="linear",
        bounds_error=False,
    )
    for i, circ in enumerate(circ_info):
        r, x, y = circ

        x_samples = x + r * np.cos(theta_samples) - 1.0  # -1 to account for 1-indexing
        y_samples = y + r * np.sin(theta_samples) - 1.0

        samples = interp_function(np.vstack([y_samples, x_samples]).T)

        hash_vals[i, 0] = np.nanmax(samples)
        hash_vals[i, 1] = np.nanmin(samples)

    return hash_vals


if __name__ == "__main__":

    # This script demonstrates how to use the generate_hash function to generate
    # the hash values for an image.
    # It also compares the hash values generated by the function in python
    # with the hash values generated by the original MATLAB implementation, and
    # verifies that they are close to within numerical precision.

    import matplotlib.pyplot as plt

    circ_data = scipy.io.loadmat("circle_info_all_imgs.mat")
    circ_info = circ_data["circInfos"]

    img = (plt.imread("00001.png") * 255).astype(np.uint8).astype(np.float32)

    hash = generate_hash(img, circ_info[0], n_interp_samples=500)

    true_hash = scipy.io.loadmat("hashed_data.mat")["hashes"][0]

    print(np.linalg.norm(hash - true_hash))
    assert np.allclose(hash, true_hash, atol=1e-9)
